compress.c:   LabelList *labelList = parameters->labelList;
compress.c:   BOOLEAN allowInstanceOverlap = parameters->allowInstanceOverlap;
compress.c:         if (parameters->noAnomalyDetection)
compress.c:      if (parameters->noAnomalyDetection)
compress.c:      if (parameters->noAnomalyDetection)
compress.c:      if (parameters->noAnomalyDetection)
compress.c:      if (parameters->noAnomalyDetection)
compress.c:         if (parameters->noAnomalyDetection)
compress.c:         if (parameters->noAnomalyDetection)
compress.c:            if (parameters->noAnomalyDetection)
compress.c:   Graph *posGraph              = parameters->posGraph;
compress.c:   BOOLEAN allowInstanceOverlap = parameters->allowInstanceOverlap;
compress.c:   LabelList *labelList         = parameters->labelList;
compress.c:      sprintf(filename, "%s.cmp", parameters->inputFileName);
compress.c:      WriteGraphToFile(fp, compressedPosGraph, parameters->labelList,
compress.c:   Graph *posGraph              = parameters->posGraph;
compress.c:   BOOLEAN allowInstanceOverlap = parameters->allowInstanceOverlap;
compress.c:   LabelList *labelList         = parameters->labelList;
compress.c:   if (parameters->outputLevel > 2)
compress.c:      FreeGraph(parameters->posGraph);
compress.c:      parameters->posGraph = compressedPosGraph;
compress.c:      FreeLabelList(parameters->labelList);
compress.c:      parameters->labelList = newLabelList;
compress.c:      if (parameters->evalMethod == EVAL_MDL)
compress.c:         parameters->posGraphDL = MDL(parameters->posGraph,
compress.c:   LabelList *labelList = parameters->labelList;
compress.c:   BOOLEAN allowInstanceOverlap = parameters->allowInstanceOverlap;
compress.c:   Graph *posGraph            = parameters->posGraph;
compress.c:   ULONG numPosEgs            = parameters->numPosEgs;
compress.c:   ULONG *posEgsVertexIndices = parameters->posEgsVertexIndices;
compress.c:   FreeLabelList(parameters->labelList);
compress.c:   parameters->labelList = newLabelList;
compress.c:   FreeGraph(parameters->posGraph);
compress.c:   parameters->posGraph = newPosGraph;
compress.c:   free(parameters->posEgsVertexIndices);
compress.c:   parameters->posEgsVertexIndices = newPosEgsVertexIndices;
compress.c:   parameters->numPosEgs = newNumPosEgs;
compress.c:   if (parameters->evalMethod == EVAL_MDL)
compress.c:      parameters->posGraphDL = MDL(newPosGraph, newLabelList->numLabels,
compress.c:   Graph *posGraph            = parameters->posGraph;
compress.c:   ULONG numPosEgs            = parameters->numPosEgs;
compress.c:   ULONG *posEgsVertexIndices = parameters->posEgsVertexIndices;
compress.c:   sprintf(filename, "%s.cmp", parameters->inputFileName);
compress.c:   if (parameters->posGraph != NULL)       // Write compressed graphs to files
compress.c:      numExamples = parameters->numPosEgs;
compress.c:         start = parameters->posEgsVertexIndices[example];
compress.c:            finish = parameters->posEgsVertexIndices[example + 1];
compress.c:            finish = parameters->posGraph->numVertices;
compress.c:         WriteGraphToFile(fp, parameters->posGraph, parameters->labelList, 0,
compress.c:   if (parameters->prob)
compress.c:      strcpy(outFileName,parameters->inputFileName);
compress.c:              parameters->currentIteration);
compress.c:         if (parameters->prob)
compress.c:   if (parameters->prob)
compress.c:         if (parameters->noAnomalyDetection)
compress.c:// de-allocates the parameters->preSubs array and the graphs it points to.
compress.c:   Graph *posGraph  = parameters->posGraph;
compress.c:   ULONG numPreSubs = parameters->numPreSubs;
compress.c:   Graph **preSubs  = parameters->preSubs;
compress.c:         posGraph = parameters->posGraph;
compress.c:   free(parameters->preSubs);
compress.c:   parameters->preSubs = NULL;
compress.c:   FreeLabelList(parameters->labelList);
compress.c:   parameters->labelList = newLabelList;
compress.c:   if (parameters->evalMethod == EVAL_MDL)
compress.c:      parameters->posGraphDL =
discover.c:// PURPOSE: Finds the normative pattern specified by parameters->norm and
discover.c:// colors all instances of it in the graph.  If parameters->currentIteration
discover.c:   ULONG currentIteration = parameters->currentIteration;
discover.c:   for (index=0; index+1 < parameters->norm && listNode != NULL; index++)
discover.c:               originalIndex = parameters->posGraph->vertices[instance->vertices[index]].originalVertexIndex;
discover.c:               if ((parameters->posGraph->vertices[instance->vertices[index]].color != NO_COLOR) && 
discover.c:                   (parameters->originalPosGraph->vertices[originalIndex].color == VERTEX_DEFAULT))
discover.c:                  parameters->originalPosGraph->vertices[originalIndex].color = posVertexColor;
discover.c:               originalIndex = parameters->posGraph->edges[instance->edges[index]].originalEdgeIndex;
discover.c:               if ((parameters->posGraph->edges[instance->edges[index]].color != NO_COLOR) && 
discover.c:                   (parameters->originalPosGraph->edges[originalIndex].color == EDGE_DEFAULT))
discover.c:                  parameters->originalPosGraph->edges[originalIndex].color = posEdgeColor;
discover.c:   ULONG limit          = parameters->limit;
discover.c:   ULONG numBestSubs    = parameters->numBestSubs;
discover.c:   ULONG beamWidth      = parameters->beamWidth;
discover.c:   BOOLEAN valueBased   = parameters->valueBased;
discover.c:   LabelList *labelList = parameters->labelList;
discover.c:   BOOLEAN prune        = parameters->prune;
discover.c:   ULONG maxVertices    = parameters->maxVertices;
discover.c:   ULONG minVertices    = parameters->minVertices;
discover.c:   ULONG outputLevel    = parameters->outputLevel;
discover.c:   ULONG evalMethod     = parameters->evalMethod;
discover.c:            parameters->outputLevel = 1; // turn off instance printing
discover.c:            parameters->outputLevel = outputLevel;
discover.c:               (parameters->noAnomalyDetection)) ||
discover.c:               (!parameters->noAnomalyDetection))) &&
discover.c:            if (parameters->currentIteration == 1)
discover.c:                     if ((parameters->prob) && (parameters->currentIteration > 1))
discover.c:            if ((! SinglePreviousSub(parentSub, parameters)) || (parameters->prob))
discover.c:               if (parameters->prob)
discover.c:      if ((parameters->prob) && (currentIteration > 1))
discover.c:         if ((! SinglePreviousSub(parentSub, parameters)) || (parameters->prob))
discover.c:            if (parameters->prob)
discover.c:   Graph *posGraph      = parameters->posGraph;
discover.c:   LabelList *labelList = parameters->labelList;
discover.c:   ULONG outputLevel    = parameters->outputLevel;
discover.c:             ((parameters->prob) && (parameters->currentIteration > 2)) ||
discover.c:	     (parameters->mdl) || (parameters->mps))
discover.c:   LabelList *labelList = parameters->labelList;
dot.c:   LabelList *labelList = parameters->originalLabelList;
dot.c:   posGraph = parameters->originalPosGraph;
dot.c:   LabelList *labelList = parameters->labelList;
dot.c:   LabelList *labelList = parameters->labelList;
evaluate.c:   Graph *posGraph              = parameters->posGraph;
evaluate.c:   double posGraphDL            = parameters->posGraphDL;
evaluate.c:   ULONG numPosEgs              = parameters->numPosEgs;
evaluate.c:   LabelList *labelList         = parameters->labelList;
evaluate.c:   BOOLEAN allowInstanceOverlap = parameters->allowInstanceOverlap;
evaluate.c:   ULONG evalMethod             = parameters->evalMethod;
evaluate.c:// parameters->log2Factorial.  NOTE: this procedure assumes that
evaluate.c:// parameters->log2Factorial[0..1] already set before first call.
evaluate.c:   if (number >= parameters->log2FactorialSize) 
evaluate.c:      parameters->log2Factorial = (double *)
evaluate.c:         realloc(parameters->log2Factorial, newSize * sizeof(double));
evaluate.c:      if (parameters->log2Factorial == NULL)
evaluate.c:      for (i = parameters->log2FactorialSize; i < newSize; i++) 
evaluate.c:         parameters->log2Factorial[i] =
evaluate.c:            Log2(i) + parameters->log2Factorial[i - 1];
evaluate.c:      parameters->log2FactorialSize = newSize;
evaluate.c:   return parameters->log2Factorial[number];
evaluate.c:                          parameters->posGraph,
evaluate.c:                          parameters->numPosEgs,
evaluate.c:                          parameters->posEgsVertexIndices, start);
extend.c:   Graph *posGraph = parameters->posGraph;
extend.c:   LabelList *labelList = parameters->labelList;
extend.c:   sprintf(subLabelString, "%s_%lu", SUB_LABEL_STRING, (parameters->currentIteration-1));
extend.c:   Graph *posGraph              = parameters->posGraph;
extend.c:   LabelList *labelList         = parameters->labelList;
extend.c:   BOOLEAN allowInstanceOverlap = parameters->allowInstanceOverlap;
extend.c:   double threshold             = parameters->threshold;
extend.c:      if ((parameters->prob) && (parameters->currentIteration > 1)) {
extend.c:                ((parameters->prob) && (parameters->currentIteration > 1)))
gbad.c:                           parameters->labelList, MAX_DOUBLE,
gbad.c:                           parameters->labelList, MAX_DOUBLE,
gbad.c:   Graph *posGraph = parameters->posGraph;
gbad.c:           parameters->maxAnomalousScore) &&
gbad.c:           parameters->minAnomalousScore))
gbad.c:         if (parameters->currentIteration > 1)
gbad.c:               if ((parameters->posGraph->vertices[firstInstanceListNode->instance->vertices[i]].color != NO_COLOR) && 
gbad.c:                   (parameters->originalPosGraph->vertices[orignalIndex].color != POSITIVE_ANOM_VERTEX))
gbad.c:                  parameters->originalPosGraph->vertices[orignalIndex].color = POSITIVE_PARTIAL_ANOM_VERTEX;
gbad.c:               if ((parameters->labelList->labels[posGraph->vertices[firstInstanceListNode->instance->vertices[i]].label].labelType == STRING_LABEL) &&
gbad.c:	           (strncmp(parameters->labelList->labels[posGraph->vertices[firstInstanceListNode->instance->vertices[i]].label].labelValue.stringLabel,
gbad.c:               if ((parameters->posGraph->edges[firstInstanceListNode->instance->edges[i]].color != NO_COLOR) && 
gbad.c:                   (parameters->originalPosGraph->edges[orignalIndex].color != POSITIVE_ANOM_EDGE))
gbad.c:                  parameters->originalPosGraph->edges[orignalIndex].color = POSITIVE_PARTIAL_ANOM_VERTEX;
gbad.c:         ULONG numPosEgs = parameters->numPosEgs;
gbad.c:         ULONG *posEgsVertexIndices = parameters->posEgsVertexIndices;
gbad.c:         if (parameters->plads)
gbad.c:            WriteAnomGraphToFile(instanceGraph, parameters->labelList, 0,
gbad.c:                                 parameters->partitionNum, instanceNum,
gbad.c:   if (parameters->currentIteration == 1)
gbad.c:      orignalIndex = parameters->posGraph->vertices[vertexIndex].originalVertexIndex;
gbad.c:      if ((parameters->posGraph->vertices[vertexIndex].color != NO_COLOR) && 
gbad.c:          (parameters->originalPosGraph->vertices[orignalIndex].color != POSITIVE_ANOM_VERTEX))
gbad.c:         parameters->originalPosGraph->vertices[orignalIndex].color = 
gbad.c:            if ((parameters->currentIteration == 1) && 
gbad.c:                (parameters->originalPosGraph->vertices[orignalIndex].color != NO_COLOR))
gbad.c:               parameters->originalPosGraph->vertices[orignalIndex].color = 
gbad.c:            if (!parameters->mps)
gbad.c:            if (parameters->originalPosGraph->vertices[graph->vertices[vertexIndex].originalVertexIndex].anomalousValue > 
gbad.c:               parameters->originalPosGraph->vertices[graph->vertices[vertexIndex].originalVertexIndex].anomalousValue = 
gbad.c:   if (parameters->currentIteration == 1)
gbad.c:      orignalIndex = parameters->posGraph->edges[edgeIndex].originalEdgeIndex;
gbad.c:      if (parameters->originalPosGraph->edges[orignalIndex].color != 
gbad.c:         parameters->originalPosGraph->edges[orignalIndex].color = 
gbad.c:            if (parameters->currentIteration == 1)
gbad.c:               parameters->originalPosGraph->edges[orignalIndex].color = 
gbad.c:            if (!parameters->mps)
gbad.c:            if (parameters->originalPosGraph->edges[graph->edges[edgeIndex].originalEdgeIndex].anomalousValue > 
gbad.c:               parameters->originalPosGraph->edges[graph->edges[edgeIndex].originalEdgeIndex].anomalousValue = 
gbad.c:   LabelList *labelList = parameters->labelList;
gbad.c:   Graph *graph = parameters->posGraph;
gbad.c:   ULONG numPosEgs = parameters->numPosEgs;
gbad.c:   ULONG *posEgsVertexIndices = parameters->posEgsVertexIndices;
gbad.c:   sprintf(subLabelString, "%s_%lu", SUB_LABEL_STRING, (parameters->currentIteration-1));
gbad.c:         if ((parameters->labelList->labels[subListNode->sub->definition->vertices[i].label].labelType == STRING_LABEL) &&
gbad.c:             (parameters->labelList->labels[subListNode->sub->definition->vertices[i].label].labelValue.stringLabel != NULL) &&
gbad.c:	     (!strncmp(parameters->labelList->labels[subListNode->sub->definition->vertices[i].label].labelValue.stringLabel,
gbad.c:         if ((parameters->labelList->labels[subListNode->sub->definition->vertices[i].label].labelType == STRING_LABEL) &&
gbad.c:             (parameters->labelList->labels[subListNode->sub->definition->vertices[i].label].labelValue.stringLabel != NULL) &&
gbad.c:	     (!strncmp(parameters->labelList->labels[subListNode->sub->definition->vertices[i].label].labelValue.stringLabel,
gbad.c:                                    (double)parameters->numPreviousInstances;
gbad.c:         if ((parameters->labelList->labels[subListNode->sub->definition->vertices[i].label].labelType == STRING_LABEL) &&
gbad.c:             (parameters->labelList->labels[subListNode->sub->definition->vertices[i].label].labelValue.stringLabel != NULL) &&
gbad.c:	     (!strncmp(parameters->labelList->labels[subListNode->sub->definition->vertices[i].label].labelValue.stringLabel,
gbad.c:	                            (double)parameters->numPreviousInstances;
gbad.c:   SubListInsert(bestSub, bestSubList, 0, FALSE, parameters->labelList);
gbad.c:   Graph *posGraph = parameters->posGraph;
gbad.c:                                          parameters->mdlThreshold) + 1;
gbad.c:                     GraphMatch(sub->definition,instanceGraph,parameters->labelList, MAX_DOUBLE,
gbad.c:                     if ((matchThreshold <= parameters->mdlThreshold) &&
gbad.c:                         (matchCost <= parameters->maxAnomalousScore))
gbad.c:   LabelList *labelList = parameters->labelList;
gbad.c:   Graph *posGraph = parameters->posGraph;
gbad.c:             (instanceListNode->instance->infoAnomalousValue <= parameters->maxAnomalousScore) &&
gbad.c:             (instanceListNode->instance->infoAnomalousValue >= parameters->minAnomalousScore))
gbad.c:               ULONG numPosEgs = parameters->numPosEgs;
gbad.c:               ULONG *posEgsVertexIndices = parameters->posEgsVertexIndices;
gbad.c:               if (parameters->plads)
gbad.c:                  WriteAnomGraphToFile(instanceGraph, parameters->labelList, 0, 
gbad.c:                                       parameters->partitionNum, instanceNum,
gbad.c:   Graph *posGraph = parameters->posGraph;
gbad.c:   if (parameters->norm > 1)
gbad.c:      for (i=1; i<parameters->norm; i++)
gbad.c:	           parameters->norm);
gbad.c:	    i = parameters->norm;
gbad.c:   if (parameters->bestSub)
gbad.c:               LabelList *labelList = parameters->labelList;
gbad.c:            strcat(gmCommand,parameters->bestSubFile);
gbad.c:   printf("Normative Pattern (%lu):\n",parameters->norm);
gbad.c:   parameters->maxVertices = bestNumVertices;
gbad.c:   parameters->minVertices = bestNumVertices;
gbad.c:   Graph *posGraph = parameters->posGraph;
gbad.c:   if (parameters->norm > 1)
gbad.c:      for (i=1; i<parameters->norm; i++)
gbad.c:	           parameters->norm);
gbad.c:	    i = parameters->norm;
gbad.c:   if (parameters->bestSub)
gbad.c:               LabelList *labelList = parameters->labelList;
gbad.c:            strcat(gmCommand,parameters->bestSubFile);
gbad.c:   printf("Normative Pattern (%lu):\n",parameters->norm);
gbad.c:   parameters->maxVertices = bestNumVertices;
gbad.c:   parameters->minVertices = bestNumVertices - 
gbad.c:                             (bestNumVertices * parameters->mpsThreshold);
gbad.c:   LabelList *labelList = parameters->labelList;
gbad.c:   Graph *posGraph = parameters->posGraph;
gbad.c:             ((sub->definition->numVertices + sub->definition->numEdges) * (1.0 - parameters->mpsThreshold)))
gbad.c:   matchThreshold = ((sub->definition->numVertices + sub->definition->numEdges) * parameters->mpsThreshold);
gbad.c:         if ((matchThreshold <= parameters->mpsThreshold) &&
gbad.c:             (matchCost <= parameters->maxAnomalousScore))
gbad.c:             (instanceListNode->instance->mpsAnomalousValue <= parameters->maxAnomalousScore) &&
gbad.c:             (instanceListNode->instance->mpsAnomalousValue >= parameters->minAnomalousScore))
gbad.c:               ULONG numPosEgs = parameters->numPosEgs;
gbad.c:               ULONG *posEgsVertexIndices = parameters->posEgsVertexIndices;
gbad.c:               if (parameters->plads)
gbad.c:                  WriteAnomGraphToFile(instanceGraph, parameters->labelList, 0, 
gbad.c:                                       parameters->partitionNum, instanceNum,
gbad.c:      saveEvalMethod = parameters->evalMethod;
gbad.c:      parameters->evalMethod = EVAL_MDL;
gbad.c:      parameters->evalMethod = saveEvalMethod;
gbad.c://      printf("Normative Pattern (%lu):\n",parameters->norm);
gbad.c://      for (i=1; i<parameters->norm; i++)
gbad.c://                   parameters->norm);
gbad.c://            i = parameters->norm;
gbad.c:      if (parameters->bestSub)
gbad.c:                  LabelList *labelList = parameters->labelList;
gbad.c:               strcat(gmCommand,parameters->bestSubFile);
gbad.c:         printf("Normative Pattern (%lu):\n",parameters->norm);
gbad.c:         printf("Normative Pattern (%lu):\n",parameters->norm);
gbad.c:         for (i=1; i<parameters->norm; i++)
gbad.c:                      parameters->norm);
gbad.c:               i = parameters->norm;
gbad.c:                                           parameters->mpsThreshold) + 1;
gbad.c:                           GraphMatch(sub->definition,instanceGraph,parameters->labelList, MAX_DOUBLE,
gbad.c:                           if ((matchThreshold <= parameters->mdlThreshold) &&
gbad.c:                               (matchCost <= parameters->maxAnomalousScore))
gbad.c:                      (parameters->optimize))
graph2dot_main.c:   strcpy(parameters->inputFileName, argv[1]);
graph2dot_main.c:   parameters->labelList = AllocateLabelList();
graph2dot_main.c:   parameters->directed = TRUE;
graph2dot_main.c:   parameters->posGraph = NULL;
graph2dot_main.c:   parameters->numPosEgs = 0;
graph2dot_main.c:   parameters->posEgsVertexIndices = NULL;
graph2dot_main.c:   FreeGraph(parameters->posGraph);
graph2dot_main.c:   FreeLabelList(parameters->labelList);
graph2dot_main.c:   free(parameters->posEgsVertexIndices);
graphops.c:   info.graph = parameters->posGraph;
graphops.c:   info.labelList = parameters->labelList;
graphops.c:   info.numPosEgs = parameters->numPosEgs;
graphops.c:   info.posEgsVertexIndices = parameters->posEgsVertexIndices;
graphops.c:   info.directed = parameters->directed;
graphops.c:   info.posGraphVertexListSize = parameters->posGraphVertexListSize;
graphops.c:   info.posGraphEdgeListSize = parameters->posGraphEdgeListSize;
graphops.c:   info.vertexOffset = (parameters->posGraph == NULL) ? 0 : parameters->posGraph->numVertices;
graphops.c:   GP_read_graph(&info, parameters->inputFileName);
graphops.c:   parameters->posGraph = info.graph;
graphops.c:   parameters->labelList = info.labelList;
graphops.c:   parameters->numPosEgs = info.numPosEgs;
graphops.c:   parameters->posEgsVertexIndices = info.posEgsVertexIndices;
graphops.c:   parameters->posGraphVertexListSize = info.posGraphVertexListSize;
graphops.c:   parameters->posGraphEdgeListSize = info.posGraphEdgeListSize;
graphops.c:   if (parameters->posGraph == NULL)
graphops.c:      parameters->originalPosGraph = NULL;
graphops.c:      parameters->originalPosGraph = CopyGraph(parameters->posGraph);
graphops.c:   parameters->originalLabelList = AllocateLabelList();
graphops.c:   for (index=0; index != parameters->labelList->numLabels; index++)
graphops.c:      StoreLabel(&(parameters->labelList->labels[index]), parameters->originalLabelList);
graphops.c:   info.labelList = parameters->labelList;
graphops.c:   info.preSubs = parameters->preSubs;
graphops.c:   info.numPreSubs = parameters->numPreSubs;
graphops.c:   info.directed = parameters->directed;
graphops.c:   GP_read_graph(&info, parameters->psInputFileName);
graphops.c:   parameters->labelList = info.labelList;
graphops.c:   parameters->preSubs = info.preSubs;
graphops.c:   parameters->numPreSubs = info.numPreSubs;
graphops.c:   LabelList *labelList = parameters->labelList;
graphops.c:   ULONG partitionNum = parameters->partitionNum;
graphops.c:               if (!parameters->mps)
graphops.c:               if (!parameters->mps)
main.c:// 12/10/09  Eberle     Removed parameters->similarity.
main.c:   if (parameters->numPreSubs > 0)
main.c:   if (parameters->iterations > 1)
main.c:   parameters->currentIteration = iteration;
main.c:   while ((iteration <= parameters->iterations) && (!done))
main.c:             parameters->numPosEgs, parameters->posGraph->numVertices,
main.c:             parameters->posGraph->numEdges);
main.c:      if (parameters->evalMethod == EVAL_MDL)
main.c:         printf(", %.0f bits\n", parameters->posGraphDL);
main.c:      printf("%lu unique labels\n", parameters->labelList->numLabels);
main.c:      if ((parameters->prob) && (iteration > 1))
main.c:         parameters->minVertices = 1;
main.c:         parameters->maxVertices = 2;
main.c:      ULONG saveNumBestSubs = parameters->numBestSubs;
main.c:      if ((iteration == 1) && (!parameters->noAnomalyDetection) &&
main.c:          (parameters->norm > parameters->numBestSubs))
main.c:         parameters->numBestSubs = parameters->norm;
main.c:      if ((parameters->prob) && (iteration > 1))
main.c:         parameters->prune = FALSE;
main.c:         parameters->numBestSubs = saveNumBestSubs;
main.c:         if (parameters->mdl)
main.c:         if (parameters->mps)
main.c:         if (parameters->prob)
main.c:         if (parameters->outputLevel > 1) 
main.c:         if (parameters->outputToFile) 
main.c:            outputFile = fopen(parameters->outFileName, "a");
main.c:                      parameters->outFileName);
main.c:               parameters->outputToFile = FALSE;
main.c:                             parameters->labelList, 0, 0,
main.c:         if (iteration < parameters->iterations) 
main.c:            if (parameters->evalMethod == EVAL_SETCOVER) 
main.c:	       if ((iteration == 1) && (parameters->prob))
main.c:	                 parameters->norm);
main.c:            if (parameters->evalMethod == EVAL_SETCOVER) 
main.c:               if (parameters->numPosEgs == 0) 
main.c:               if (parameters->posGraph->numEdges == 0) 
main.c:         if ((iteration == parameters->iterations) && (parameters->compress))
main.c:            if (parameters->evalMethod == EVAL_SETCOVER)
main.c:      if ((parameters->prob) && (iteration == 1) && (subList->head != NULL))
main.c:         parameters->numPreviousInstances = subList->head->sub->numInstances;
main.c:      if ((parameters->prob) && (iteration > 1) && (subList->head != NULL))
main.c:         parameters->numPreviousInstances = subList->head->sub->numInstances;
main.c:      if (parameters->iterations > 1) 
main.c:      parameters->currentIteration = iteration;
main.c:   if (parameters->dotToFile)
main.c:      for (index=0; index < parameters->originalPosGraph->numVertices; index++)
main.c:         if (parameters->originalPosGraph->vertices[index].anomalousValue < minAnomalousValue)
main.c:            minAnomalousValue = parameters->originalPosGraph->vertices[index].anomalousValue;
main.c:      for (index=0; index < parameters->originalPosGraph->numEdges; index++)
main.c:         if (parameters->originalPosGraph->edges[index].anomalousValue < minAnomalousValue)
main.c:            minAnomalousValue = parameters->originalPosGraph->edges[index].anomalousValue;
main.c:      for (index=0; index < parameters->originalPosGraph->numVertices; index++)
main.c:         if (parameters->originalPosGraph->vertices[index].anomalousValue == minAnomalousValue)
main.c:            parameters->originalPosGraph->vertices[index].color = POSITIVE_ANOM_VERTEX;
main.c:      for (index=0; index < parameters->originalPosGraph->numEdges; index++)
main.c:         if (parameters->originalPosGraph->edges[index].anomalousValue == minAnomalousValue)
main.c:            parameters->originalPosGraph->edges[index].color = POSITIVE_ANOM_EDGE;
main.c:      WriteGraphToDotFile(parameters->dotFileName, parameters);
main.c:   strcpy(parameters->dotFileName, "none");
main.c:   parameters->dotToFile = FALSE;
main.c:   parameters->directed = TRUE;
main.c:   parameters->limit = 0;
main.c:   parameters->numBestSubs = 3;
main.c:   parameters->beamWidth = 4;
main.c:   parameters->valueBased = FALSE;
main.c:   parameters->prune = FALSE;
main.c:   strcpy(parameters->outFileName, "none");
main.c:   parameters->outputToFile = FALSE;
main.c:   parameters->outputLevel = 2;
main.c:   parameters->allowInstanceOverlap = FALSE;
main.c:   parameters->threshold = 0.0;
main.c:   parameters->evalMethod = EVAL_MDL;
main.c:   parameters->iterations = 1;
main.c:   strcpy(parameters->psInputFileName, "none");
main.c:   parameters->predefinedSubs = FALSE;
main.c:   parameters->minVertices = 1;
main.c:   parameters->maxVertices = 0; // i.e., infinity
main.c:   parameters->compress = FALSE;
main.c:   parameters->mdl = FALSE;
main.c:   parameters->mdlThreshold = 0.0;
main.c:   parameters->mpsThreshold = 0.0;
main.c:   parameters->prob = FALSE;
main.c:   parameters->mps = FALSE;
main.c:   parameters->maxAnomalousScore = MAX_DOUBLE;
main.c:   parameters->minAnomalousScore = 0.0;
main.c:   parameters->noAnomalyDetection = TRUE;
main.c:   parameters->norm = 1;
main.c:   parameters->optimize = TRUE;
main.c:   parameters->partitionNum = 0;
main.c:   strcpy(parameters->graphInputFile, "none");
main.c:   parameters->plads = FALSE;
main.c:   strcpy(parameters->bestSubFile, "none");
main.c:   parameters->bestSub = FALSE;
main.c:         parameters->beamWidth = ulongArg;
main.c:         parameters->compress = TRUE;
main.c:         parameters->evalMethod = ulongArg;
main.c:         parameters->iterations = ulongArg;
main.c:         parameters->limit = ulongArg;
main.c:         parameters->maxVertices = ulongArg;
main.c:         parameters->minVertices = ulongArg;
main.c:         parameters->numBestSubs = ulongArg;
main.c:         strcpy(parameters->outFileName, argv[i]);
main.c:         parameters->outputToFile = TRUE;
main.c:         parameters->outputLevel = ulongArg;
main.c:         parameters->allowInstanceOverlap = TRUE;
main.c:         parameters->prune = TRUE;
main.c:         strcpy(parameters->psInputFileName, argv[i]);
main.c:         parameters->predefinedSubs = TRUE;
main.c:         parameters->threshold = doubleArg;
main.c:         parameters->directed = FALSE;
main.c:         parameters->valueBased = TRUE;
main.c:         parameters->mdl = TRUE;
main.c:         parameters->mdlThreshold = doubleArg;
main.c:         parameters->prob = TRUE;
main.c:         parameters->iterations = ulongArg;  // overrides -iterations specification
main.c:         parameters->maxAnomalousScore = 1.0;  // overrides default of MAX_DOUBLE
main.c:         parameters->mps = TRUE;
main.c:         parameters->mpsThreshold = doubleArg;
main.c:	     (parameters->prob))
main.c:         parameters->maxAnomalousScore = doubleArg;
main.c:         parameters->minAnomalousScore = doubleArg;
main.c:         parameters->norm = ulongArg;
main.c:         parameters->optimize = FALSE;
main.c:         parameters->partitionNum = ulongArg;
main.c:         strcpy(parameters->graphInputFile, argv[i]);
main.c:         parameters->plads = TRUE;
main.c:         strcpy(parameters->bestSubFile, argv[i]);
main.c:         parameters->bestSub = TRUE;
main.c:         strcpy(parameters->dotFileName, argv[i]);
main.c:         parameters->dotToFile = TRUE;
main.c:   if ((parameters->mdl) || (parameters->prob) || (parameters->mps)) 
main.c:      parameters->noAnomalyDetection = FALSE;
main.c:   if (parameters->iterations == 0)
main.c:      parameters->iterations = MAX_UNSIGNED_LONG; // infinity
main.c:   parameters->log2Factorial = (double *) malloc(2 * sizeof(double));
main.c:   if (parameters->log2Factorial == NULL)
main.c:      OutOfMemoryError("GetParameters:parameters->log2Factorial");
main.c:   parameters->log2FactorialSize = 2;
main.c:   parameters->log2Factorial[0] = 0; // lg(0!)
main.c:   parameters->log2Factorial[1] = 0; // lg(1!)
main.c:   strcpy(parameters->inputFileName, argv[argc - 1]);
main.c:   parameters->labelList = AllocateLabelList();
main.c:   parameters->posGraph = NULL;
main.c:   parameters->numPosEgs = 0;
main.c:   parameters->posEgsVertexIndices = NULL;
main.c:   if (parameters->evalMethod == EVAL_MDL)
main.c:      parameters->posGraphDL = MDL(parameters->posGraph,
main.c:                                  parameters->labelList->numLabels, parameters);
main.c:   parameters->numPreSubs = 0;
main.c:   if (parameters->predefinedSubs)
main.c:   parameters->incrementList = malloc(sizeof(IncrementList));
main.c:   parameters->incrementList->head = NULL;
main.c:   if (parameters->outputToFile) 
main.c:      outputFile = fopen(parameters->outFileName, "w");
main.c:                parameters->outFileName);
main.c:   if (parameters->numPosEgs == 0)
main.c:   if (parameters->maxVertices == 0)
main.c:      parameters->maxVertices = parameters->posGraph->numVertices;
main.c:   if (parameters->maxVertices < parameters->minVertices)
main.c:   if (parameters->limit == 0)
main.c:      parameters->limit = parameters->posGraph->numEdges / 2;
main.c:   printf("  Input file..................... %s\n",parameters->inputFileName);
main.c:   printf("  Predefined substructure file... %s\n",parameters->psInputFileName);
main.c:   printf("  Output file.................... %s\n",parameters->outFileName);
main.c:   printf("  Dot file....................... %s\n",parameters->dotFileName);
main.c:   printf("  Beam width..................... %lu\n",parameters->beamWidth);
main.c:   PrintBoolean(parameters->compress);
main.c:   switch(parameters->evalMethod) 
main.c:   if (parameters->mdl) {
main.c:      printf("  Information Theoretic threshold %lf\n", parameters->mdlThreshold);
main.c:   if (parameters->prob) {
main.c:   if (parameters->mps)
main.c:      printf("  Maximum Partial Sub threshold.. %lf\n", parameters->mpsThreshold);
main.c:   if (parameters->noAnomalyDetection) 
main.c:   if (!parameters->noAnomalyDetection) {
main.c:      if (parameters->maxAnomalousScore) {
main.c:         if (parameters->maxAnomalousScore == MAX_DOUBLE)
main.c:            printf("  Max Anomalous Score............ %lf\n",parameters->maxAnomalousScore);
main.c:      if (parameters->minAnomalousScore) 
main.c:         printf("  Min Anomalous Score............ %lf\n",parameters->minAnomalousScore);
main.c:      if (parameters->norm) 
main.c:         printf("  Normative Pattern.............. %lu\n",parameters->norm);
main.c:   PrintBoolean(parameters->directed);
main.c:   if (parameters->iterations == 0)
main.c:      printf("%lu\n", parameters->iterations);
main.c:   printf("  Limit.......................... %lu\n", parameters->limit);
main.c:   printf("  Minimum size of substructures.. %lu\n", parameters->minVertices);
main.c:   printf("  Maximum size of substructures.. %lu\n", parameters->maxVertices);
main.c:   printf("  Number of best substructures... %lu\n", parameters->numBestSubs);
main.c:   printf("  Output level................... %lu\n", parameters->outputLevel);
main.c:   PrintBoolean(parameters->allowInstanceOverlap);
main.c:   PrintBoolean(parameters->prune);
main.c:   if (!parameters->noAnomalyDetection) 
main.c:      PrintBoolean(parameters->optimize);
main.c:   printf("  Threshold...................... %lf\n", parameters->threshold);
main.c:   PrintBoolean(parameters->valueBased);
main.c:   printf("  Best substructure file......... %s\n",parameters->bestSubFile);
main.c:   printf("Read %lu total positive graphs\n", parameters->numPosEgs);
main.c:   if (parameters->numPreSubs > 0)
main.c:      printf("Read %lu predefined substructures\n", parameters->numPreSubs);
main.c:   FreeGraph(parameters->posGraph);
main.c:   FreeLabelList(parameters->labelList);
main.c:   free(parameters->posEgsVertexIndices);
main.c:   free(parameters->log2Factorial);
sgiso.c:// parameters->allowInstanceOverlap=FALSE, then remaining instances
sgiso.c:            if (parameters->allowInstanceOverlap ||
sgiso.c:               thresholdLimit = parameters->threshold *
sgiso.c:               if (GraphMatch(subGraph, instanceGraph, parameters->labelList,
subops.c:         if (parameters->partitionNum > 0 && !parameters->plads)
subops.c:                                 parameters->labelList, 0, 0,
subops.c:                                 parameters->partitionNum, counter,
subops.c:                                 parameters->graphInputFile);
subops.c:   LabelList *labelList = parameters->labelList;
subops.c:   ULONG outputLevel = parameters->outputLevel;
subops.c:   ULONG outputLevel = parameters->outputLevel;
subops.c:      parameters->outputLevel = 1; // turn off instance printing
subops.c:      parameters->outputLevel = outputLevel;
subops.c:   Graph *posGraph = parameters->posGraph;
subops.c:   ULONG numPosEgs = parameters->numPosEgs;
subops.c:   ULONG *posEgsVertexIndices = parameters->posEgsVertexIndices;
subops.c:   LabelList *labelList = parameters->labelList;
